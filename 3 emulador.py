#!/usr/bin/env python
# coding: utf-8


import xarray as xr
import numpy as np
import pandas as pd
#import cartopy.crs as ccrs
#from cartopy import config
#import cartopy
import matplotlib.pyplot as plt
from datetime import datetime
from datetime import timedelta
import matplotlib.dates as mdates
import cftime
from scipy.optimize import curve_fit
from mpmath import nsum
from mpmath import exp
from mpmath import log



#------------------------------------------
def weighted_avg(data,weights): #data must be #time, lat, lon
    return data.weighted(weights).mean(dim=('lat','lon'))
#    return np.mean(np.average(data, axis=1, weights=weights),axis=1) #average weighted over latitude, and normal over longitude
#------------------------------------------

# Below you can add multiple netCDF files if you wish
#NetCDF PlaSim output file           # generated by ...
file1   = 'output_allvar_monthly_1_50.nc'             # preindustrial
file2   = 'output_allvar_monthly_1_100_2xCO2.nc'      # doubling constant
file3   = 'output.onepctco2.nc'                       # 1% increase
file4   = 'double_output_standard_monthly_1_25.nc'    #CO2 pulse
# file_list = [file1, file2] # alternatively: [file1, file2, ...]
file_list = [file1, file2, file3, file4]
temperatures = []
datapoints = np.zeros(len(file_list), dtype="int64")

#open dataset and fix timestamps
for amount in range(len(file_list)):
    try:
        DATA = xr.open_mfdataset(file_list[amount])
        print(f"Opened {file_list[amount]} the regular way.")
    except ValueError:
        DATA = xr.open_mfdataset(file_list, decode_times=False)
        times   = cftime.num2date(DATA.time.data, DATA.time.units, 
                                  calendar=DATA.time.calendar, has_year_zero=True)
        time = xr.DataArray(times, dims=('time'), attrs=DATA.time.attrs)
        DATA['time']=time
        DATA.set_coords('time')
        print(f"Manually adjusted time stamps in {file_list}")

    #load variables to plot
    lon     = DATA['lon'].data #1D array longitudes
    lat     = DATA['lat'].data #1D array lattitudes
    lev     = DATA['lev'].data #1D array of vertical levels
    time    = DATA['time'].data #1D array of time 
    tsfc    = DATA['ts'].data # surface temperature [time,lat,lon]
    sic     = DATA['sic'].data # sea ice concentration
    toa_net = DATA['rst']+DATA['rlut'] #net energy balance at top of atmosphere
    precip  =  24*60*60*1000*(DATA['prc'].data + DATA['prl'].data + DATA['prsn'].data) #total precipitation in mm/day

    ndays = (time[-1]-time[0]).total_seconds()/86400 # total number of days
    usedaily = (ndays<=2*360)
    if usedaily:   
        DATA_d = DATA.resample(time='1D').mean() # daily averaged data
    DATA_m = DATA.resample(time='1M').mean() # create monthly averaged data
    DATA_y = DATA.resample(time='1Y').mean() #create yearly averaged data

    #create weights for grid-cell weighted global means
    gw = np.cos(np.deg2rad(DATA.lat)) #For a rectangular grid the cosine of the latitude is proportional to the grid cell area.
    we_temp = weighted_avg(DATA_y.ts, gw)-273.15
    old_temp_size = len(temperatures)
    for amounts in range(len(DATA_y.ts)):
        temperatures.append(we_temp[amounts])
    
    
    timelength = len(temperatures) - old_temp_size
    datapoints[amount] = timelength




# def func(diff, q1, d1, q2, d2):
#     return ((q1/d1) * np.exp(- (diff/d1) )) + ((q2/d2)*np.exp(- (diff/d2) ))

def func(t, q1, d1, q2, d2): 
    out = np.zeros(len(t))
    for time in range(len(t)):
        used_time = np.arange(0, time+1, 1)
        for tao in range(len(used_time)):
            F = F0 * log(C[tao])
            out[time] += ((q1/d1) * exp(- ((time-tao) /d1) )) + ((q2/d2) * exp(- ((time-tao) /d2) )) * F
    return out




datapoints


# ### Dividing temperatures



set1 = datapoints[0]
set2 = datapoints[0]+datapoints[1]
set3 = datapoints[0]+datapoints[1]+datapoints[2]
set4 = datapoints[0]+datapoints[1]+datapoints[2]+datapoints[3]

pre_indus_T = temperatures[:set1]
doubling_T = temperatures[set1:set2]
oneptinc_T = temperatures[set2:set3]
pulse_double_T = temperatures[set3:]

mean_prein_T = np.mean(pre_indus_T)
new_T_double = doubling_T - mean_prein_T
new_T_oneptinc = oneptinc_T - mean_prein_T
new_T_pulse = pulse_double_T - mean_prein_T


# # Determining parameters

# ### Pulse Doubling



t = len(new_T_pulse)
print(t)

new_temp = new_T_pulse
C = np.full(t, 1, dtype="float")
C[0] = 2
new_time = np.arange(0, t, 1)

#Guessing values  
q1 = [0.33]
d1 = [239]
q2 = [0.41]
d2 = [4.1]
coefin = np.concatenate((q1, d1, q2, d2))
popt, pcov = curve_fit(func, new_time, new_temp, coefin)
# popt = coefin
F0 = 3.74 / np.log(2)
T = np.zeros(t)
T_oneexp = np.zeros(t)
for time in range(t): #t in range of years of simulation
    temp_time = np.arange(0, time+1, 1)    
    summation = 0
    summation_oneexp = 0
    for tao in range(len(temp_time)):
        F = F0 * np.log(C[tao])
        diff = time - tao
        R_T = ((popt[0]/popt[1]) * np.exp(- (diff/popt[1]) )) + ((popt[2]/popt[3]) * np.exp(- (diff/popt[3]) ))
        R_T_exp = ((popt[2]/popt[3]) * np.exp(- (diff/popt[3]) ))
        summation += R_T * F
        summation_oneexp += R_T_exp * F

    T[time] = summation
    T_oneexp[time] = summation_oneexp

pulse_variable = popt    

print(f"The parameters are: q1={popt[0]}, d1={popt[1]}, q2={popt[2]}, d2={popt[3]}")
plt.plot(new_time, T, label="Emulator")
plt.plot(new_time, new_temp, label="PlaSim")
plt.plot(new_time, T_oneexp, label="One exponential")
plt.legend()
plt.grid()
plt.title("Pulse Doubling", fontsize=16)
plt.xlabel("years wrs pre-industrial")
plt.ylabel("temperature wrs pre-industrial [deg C]")
plt.show()


# ### Doubling


## DOUBLING
t = len(new_T_double)
print(t)
new_temp = new_T_double
C = np.full(t, 2)    
new_time = np.arange(0, t, 1)

#Guessing values  
q1 = [0.33]
d1 = [239]
q2 = [0.41]
d2 = [4.1]
# coefin = pulse_variable
coefin = np.concatenate((q1, d1, q2, d2))
popt, pcov = curve_fit(func, new_time, new_temp, coefin)
F0 = 3.74 / np.log(2)
T = np.zeros(t)

for time in range(t): #t in range of years of simulation
    temp_time = np.arange(0, time+1, 1)    
    summation = 0
    for tao in range(len(temp_time)):
        F = F0 * np.log(C[tao])
        diff = time - tao
        R_T = ((popt[0]/popt[1]) * np.exp(- (diff/popt[1]) )) + ((popt[2]/popt[3]) * np.exp(- (diff/popt[3]) ))
        summation += R_T * F
        
    T[time] = summation 

print(f"The parameters are: q1={popt[0]}, d1={popt[1]}, q2={popt[2]}, d2={popt[3]}")
plt.plot(new_time, T, label="Emulator")
plt.plot(new_time, new_temp, label="PlaSim")
plt.legend()
plt.grid()
plt.title("Constant Doubling", fontsize=16)
plt.xlabel("years wrs pre-industrial")
plt.ylabel("temperature wrs pre-industrial [deg C]")
plt.show()




value1 = np.mean(T[-25:])
value2 = np.mean(new_temp[-25:])
value1, value2


# ### One percent increase



t = len(new_T_oneptinc)
print(t)

new_temp = new_T_oneptinc
C = np.full(t, 1, dtype="float")
C[0] = 1.01 #1% increase
for years in range(len(C)-1): 
    C[years+1] = C[years] * 1.01

new_time = np.arange(0, t, 1)

#Guessing values  
q1 = [0.33]
d1 = [239]
q2 = [0.41]
d2 = [4.1]
# coefin = pulse_variable
coefin = np.concatenate((q1, d1, q2, d2))

popt, pcov = curve_fit(func, new_time, new_temp, coefin)
F0 = 3.74 / np.log(2)
T = np.zeros(t)

for time in range(t): #t in range of years of simulation
    temp_time = np.arange(0, time+1, 1)    
    summation = 0
    summation_oneexpA = 0
    summation_oneexpB = 0
    for tao in range(len(temp_time)):
        F = F0 * np.log(C[tao])
        diff = time - tao
        R_T = ((popt[0]/popt[1]) * np.exp(- (diff/popt[1]) )) + ((popt[2]/popt[3]) * np.exp(- (diff/popt[3]) ))
        summation += R_T * F
        
    T[time] = summation 
    
    
print(f"The parameters are: q1={popt[0]}, d1={popt[1]}, q2={popt[2]}, d2={popt[3]}")
plt.plot(new_time, T, label="Emulator")
plt.plot(new_time, new_temp, label="PlaSim")
plt.legend()
plt.grid()
plt.title("One percent increase",fontsize=16)
plt.xlabel("years wrs pre-industrial")
plt.ylabel("temperature wrs pre-industrial [deg C]")
plt.show()




value1 = np.mean(T[-5:])
value2 = np.mean(new_temp[-5:])
value1, value2


gem # In[435]:


def file_to_pandas(file):
    """Read a GESLA data file into a pandas.DataFrame object. Metadata is
    returned as a pandas.Series object.
    Args:
        filename (string): name of the GESLA data file. Do not prepend path.
        return_meta (bool, optional): determines if metadata is returned as
            a second function output. Defaults to True.
    Returns:
        pandas.DataFrame: sea-level values and flags with datetime index.
        pandas.Series: record metadata. This return can be excluded by
            setting return_meta=False.
    """


    with open(file, "r") as f:
        data = pd.read_csv(
            f,
            skiprows=38,
            sep="\s+",
#             parse_dates=[[0, 1]],
            index_col=0,
        )
    return data


# In[473]:


file1 = "RCP3PD_MIDYR_CONC.DAT" #RCP 2.6
file2 = "RCP45_MIDYR_CONC.DAT" # RCP 4.5
file3 = "RCP6_MIDYR_CONC.DAT" #Â RCP 6
file4 = "RCP85_MIDYR_CONC.DAT" #RCP 8.5
all_files = [file1, file2, file3, file4]
# all_files = [file1]

txt = ["RCP 2.6", "RCP 4.5", "RCP 6", "RCP 8.5"]

for amount in range(len(all_files)):
    
    df = file_to_pandas(all_files[amount])
    new_dat = df.loc[1850:2100]
    CO2 = new_dat["CO2"] 
    t = len(CO2)
    pulse_variable = popt 
    C0 = 285
    T = np.zeros(t)

    for time in range(t): #t in range of years of simulation
        temp_time = np.arange(0, time+1, 1)    
        summation = 0
        for tao in range(len(temp_time)):
            C = CO2.iloc[time]
            ratio = C/C0
            F = F0 * np.log(ratio)
            diff = time - tao
            R_T = ((pulse_variable[0]/pulse_variable[1]) * np.exp(- (diff/pulse_variable[1]) )) + ((pulse_variable[2]/pulse_variable[3]) * np.exp(- (diff/pulse_variable[3]) ))
            summation += R_T * F

        T[time] = summation 
        
    plt.plot(T/20, label=f"{txt[amount]}")

    
plt.xlabel("Years from pre-industrial [years]")
plt.ylabel("Temperature wrs pre-industrial [$^oC$]")
plt.title("RCP respones", fontsize=16)
plt.legend()
plt.grid()
plt.show()


# In[458]:


CO2


# In[463]:


CO2

